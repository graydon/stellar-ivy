#lang ivy1.7

type value
type node
type nset # sets of nodes

relation well_behaved(N:node)
relation intertwined(N:node)
relation intact(N:node)

# intact nodes are intertwined
axiom intact(N) -> intertwined(N)

# intertwined nodes are well-behaved
axiom intertwined(N) -> well_behaved(N)

relation member(N:node, S:nset)
relation is_quorum(Q:nset)

# quorum intersection
# QAG edge nset -> node
# The intersection of any two quorums Q1, Q2 containing intertwined nodes contains at a well-behaved node.
trusted isolate qi_intertwined = {
    property (exists N1 . intertwined(N1) & is_quorum(Q1) & member(N1,Q1)) &
                 (exists N2 . intertwined(N2) & is_quorum(Q2) & member(N2,Q2))
             -> exists N3 . well_behaved(N3) & member(N3,Q1) & member(N3,Q2)
}
trusted isolate qi_intact = {
    property (exists N1 . intact(N1) & is_quorum(Q1) & member(N1,Q1)) &
                 (exists N2 . intact(N2) & is_quorum(Q2) & member(N2,Q2))
             -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2)
}

relation blocks_slices(S:nset, N:node)

# if set R blocks an intact node then R contains an intact node
# QAG edge nset -> node
axiom (exists N . intact(N) & blocks_slices(S,N)) -> exists N2 . member(N2,S) & intact(N2)

# the set of all intact nodes is a quorum
axiom exists Q . (forall N . member(N,Q) <-> intact(N)) & is_quorum(Q)


object protocol = {
    relation voted_nominate(N:node, V:value)
    relation accepted_nominate(N:node, V:value)
    relation confirmed_nominate(N:node, V:value)
    relation has_candidate_value(N:node)

    # N1 heard that N2 {voted, accepted, confirmed} nominate(V)
    relation received_vote_nominate(N1:node, N2:node, V:value)
    relation received_accept_nominate(N1:node, N2:node, V:value)
    relation received_confirm_nominate(N1:node, N2:node, V:value)

    object actions = {
        after init {
            voted_nominate(N, V) := false;
            accepted_nominate(N, V) := false;
            confirmed_nominate(N, V) := false;
            has_candidate_value(N) := false;
            received_vote_nominate(N1, N2, V) := false;
            received_accept_nominate(N1, N2, V) := false;
            received_confirm_nominate(N1, N2, V) := false;
        }

        # n votes for nominate(v).
        action vote_nominate(n:node, v:value) = {
            # n is not allowed to vote for nominate(v)
            # if it already has a candidate value.
            assume ~has_candidate_value(n);

            # bookkeeping.
            voted_nominate(n, v) := true;
        }


        # na heard that nb voted for nominate(v).
        # This may make it possible for na to accept nominate(v).
        action receive_vote_nominate(na:node, nb:node, v:value) = {

            # nb better have voted for nominate(v).
            assume voted_nominate(nb, v);

            # Bookkeeping.
            received_vote_nominate(na, nb, v) := true;

            # Check if na can accept nominate(v).
            if (exists Q . is_quorum(Q) & member(na,Q) &
                    (forall N . member(N,Q) ->
                     (received_vote_nominate(na,N,v) |
                      received_accept_nominate(na,N,v)))) {
                accepted_nominate(na,v) := true;
            };
        }

        # na heard that nb voted for nominate(v).
        # This may make it possible for na to accept or confirm nominate(v).
        # In SCP-safety.ivy, it checks the confirm stuff first.
        # But I thought that it'd make more sense to accept first because
        # I might be able to both accept and confirm nominate(v).
        action receive_accept_nominate(na:node, nb:node, v:value) = {

            # nb better have voted for nominate(v).
            assume accepted_nominate(nb, v);

            # Bookkeeping.
            received_accept_nominate(na, nb, v) := true;

            # If na is a member of a quorum in which
            # everyone either voted for or accepted nominate(v),
            # then na can accept it.
            if (exists Q .
                    is_quorum(Q) &
                    member(na,Q) &
                    (forall N . member(N,Q) ->
                        (received_vote_nominate(na, N, v) |
                         received_accept_nominate(na, N, v)))) {
                accepted_nominate(na, v) := true;
            };

            # If there exists a na-blocking set in which every member
            # accepted nominate(v), then na can accept it.
            if (exists S .
                    blocks_slices(S, na) &
                    (forall N . member(N, S) -> received_accept_nominate(na, N, v))) {
                accepted_nominate(na, v) := true;
            };

            # If na is a member of a quorum in which everyone accepted nominate(v),
            # then na can confirm it.
            if (exists Q .
                    is_quorum(Q) &
                    member(na, Q) &
                    forall N . member(N,Q) -> received_accept_nominate(na, N, v)) {

                confirmed_nominate(na, v) := true;
                has_candidate_value(na) := true;
            }
        }
    }
}
