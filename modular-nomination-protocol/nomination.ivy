#lang ivy1.7

module set(t) = {
    type this
    relation member(E:t,S:this)

    relation empty(S:this)
    definition empty(S) = forall X. ~member(X, S)

    ## Union
    relation union(U:this, V:this, UV:this)
    definition union(U, V, UV) = forall X. (member(X, U) | member(X, V)) <-> member(X, UV)

    ## Intersection
    relation intersection(U:this, V:this, UV:this)
    definition intersection(U, V, UV) = forall X. (member(X, U) & member(X, V)) <-> member(X, UV)

    ## Subset
    relation subset(S:this, T:this)
    definition subset(S, T) = forall N. member(N, S) -> member(N, T)

    ## Subtract (S \ T = U)
    relation subtract(S:this, T:this, U:this)
    definition subtract(S, T, U) = forall N. (member(N, S) & ~member(N, T)) <-> member(N, U)

    individual empty_set : this
    axiom forall E. ~member(E,empty_set)

    individual universe : this
    axiom forall E. member(E,universe)
}

module node_module(value) = {
    type t
    instance nset : set(t)

    relation voted_for(X:value)
    relation accepted(X:value)
    relation confirmed(X:value)
    relation has_candidate_value
    relation received_vote(V:t, X:value)
    relation is_quorum_slice(S:nset)

    action vote_for(x:value)
    action accept(x:value)

    # Receive a vote for statement x from node v.
    action receive_vote(v:t, x:value)

    # TODO: How should I implement the quorum stuff?

    object spec = {
        before vote_for {
            assert ~has_candidate_value;
        }

        after receive_vote {
#            assert v.voted_for(x);
            assert received_vote(v, x);
        }

        before accept {
            # Assert that one of the two conditions to accept has been met.
        }
    }

    object impl = {
        implement vote_for {
            voted_for(x) := true;
            # Todo: Add the if condition here
            call accept(x);
        }

        implement receive_vote {
            received_vote(v, x) := true;
            # Todo: Add the if condition here
            call accept(x);
        }
    }
}

module network_module(node, value) = {
    relation enqueued_vote(V:node, X:value)
    action enqueue_vote(v:node, x:value)
    # This tells node a that node b voted for value x.
    action deliver_vote(a:node, b:node, x:value)


    object spec = {
        after enqueue_vote {
            assert enqueued_vote(v, x);
            call v.voted_for(x);
        }
        before deliver_vote {
            assert enqueued_vote(b, x);
        }
        after deliver_vote {
            assert a.received_vote(b, x);
        }
    }

    object impl = {
        implement enqueue_vote(v:node, x:value) {
            enqueued_vote(v, x) := true;
        }
        implement deliver_vote {
            call a.receive_vote(b, x);
        }
    }
}

type value
type id
instance node : node_module(value)
#instance node : node_module(value, id)
instance network_module(node, value)
