#lang ivy1.7

type value
type node
type nset # sets of nodes

relation well_behaved(N:node)
relation intertwined(N:node)
relation intact(N:node)

# intact nodes are intertwined
axiom intact(N) -> intertwined(N)

# intertwined nodes are well-behaved
axiom intertwined(N) -> well_behaved(N)

relation member(N:node, S:nset)
relation is_quorum(Q:nset)

# quorum intersection
# QAG edge nset -> node
# The intersection of any two quorums Q1, Q2 containing intertwined nodes contains at a well-behaved node.
trusted isolate qi_intertwined = {
    property (exists N1 . intertwined(N1) & is_quorum(Q1) & member(N1,Q1)) &
                 (exists N2 . intertwined(N2) & is_quorum(Q2) & member(N2,Q2))
             -> exists N3 . well_behaved(N3) & member(N3,Q1) & member(N3,Q2)
}
trusted isolate qi_intact = {
    property (exists N1 . intact(N1) & is_quorum(Q1) & member(N1,Q1)) &
                 (exists N2 . intact(N2) & is_quorum(Q2) & member(N2,Q2))
             -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2)
}

relation blocks_slices(S:nset, N:node)

# If set R blocks an intact node then R contains an intact node
# QAG edge nset -> node
axiom (exists N . intact(N) & blocks_slices(S,N)) -> exists N2 . member(N2,S) & intact(N2)

# The set of all intact nodes is a quorum
axiom exists Q . (forall N . member(N,Q) <-> intact(N)) & is_quorum(Q)


object protocol = {

    relation voted_nominate(N:node, X:value)
    relation accepted_nominate(N:node, X:value)
    relation confirmed_nominate(N:node, X:value)
    relation has_candidate_value(N:node)

    # N1 heard that N2 {voted, accepted} nominate(X)
    relation received_vote_nominate(N1:node, N2:node, X:value)
    relation received_accept_nominate(N1:node, N2:node, X:value)

    object actions = {
        after init {
            voted_nominate(N, X) := false;
            accepted_nominate(N, X) := false;
            confirmed_nominate(N, X) := false;
            has_candidate_value(N) := false;
            received_vote_nominate(N1, N2, X) := false;
            received_accept_nominate(N1, N2, X) := false;
        }

        # n votes for nominate(x).
        action vote_nominate(n:node, x:value) = {

            # n is not allowed to vote for nominate(x)
            # if it already has a candidate value.
            assume ~has_candidate_value(n);

            # bookkeeping.
            voted_nominate(n, x) := true;
        }


        # na heard that nb voted for nominate(x).
        # This may make it possible for na to accept nominate(x).
        action receive_vote_nominate(na:node, nb:node, x:value) = {

            # This action is possible if and only if nb has voted for nominate(v).
            assume voted_nominate(nb, x);

            # Bookkeeping.
            received_vote_nominate(na, nb, x) := true;

            # Check if na can accept nominate(v).
            if (exists Q . is_quorum(Q) & member(na, Q) &
                    (forall N . member(N,Q) ->
                     (received_vote_nominate(na, N, x) |
                      received_accept_nominate(na, N, x)))) {
                accepted_nominate(na, x) := true;
            };
        }

        # na heard that nb voted for nominate(x).
        # This may make it possible for na to accept or confirm nominate(x).
        # In SCP-safety.ivy, it checks the confirm stuff first.
        # But I thought that it'd make more sense to accept first because
        # I might be able to both accept and confirm nominate(x).
        action receive_accept_nominate(na:node, nb:node, x:value) = {

            # This action is possible if and only if nb has voted for nominate(x).
            assume accepted_nominate(nb, x);

            # Bookkeeping.
            received_accept_nominate(na, nb, x) := true;

            # If na is a member of a quorum in which
            # everyone either voted for or accepted nominate(x),
            # then na can accept it.
            if (exists Q .
                    is_quorum(Q) &
                    member(na,Q) &
                    (forall N . member(N,Q) ->
                        (received_vote_nominate(na, N, x) |
                         received_accept_nominate(na, N, x)))) {
                accepted_nominate(na, x) := true;
            };

            # If there exists a na-blocking set in which every member
            # accepted nominate(x), then na can accept it.
            if (exists S .
                    blocks_slices(S, na) &
                    (forall N . member(N, S) -> received_accept_nominate(na, N, x))) {
                accepted_nominate(na, x) := true;
            };

            # If na is a member of a quorum in which everyone accepted nominate(x),
            # then na can confirm it.
            if (exists Q .
                    is_quorum(Q) &
                    member(na, Q) &
                    forall N . member(N,Q) -> received_accept_nominate(na, N, x)) {

                confirmed_nominate(na, x) := true;
                has_candidate_value(na) := true;
            }
        }

        # TODO: Create a Byzantine step
        export vote_nominate
        export receive_vote_nominate
        export receive_accept_nominate
    }

    isolate liveness = {
        # Here, we prove that the set of intact nodes will
        # *eventually* produce a candidate value.
        #
        # We will do so without using temporal logic.
        # Let X be a value and N be an intertwined node.
        # Suppose that N has voted for X.
        # At any point, at least one of the following statements must be true:
        # 1) N has confirmed nominate(X), OR
        # 2) There exists a message about X that has not been delivered.
        #
        # In other words, what I'm trying to prove here is
        # "Once sufficient messages have been delivered, N will confirm nominate(X)."
        #
        # Unfortunately, there is something wrong with the code,
        # or IVy can't prove this directly. (or both!)
        # Run "ivy_check diagnose=true nomination-liveness.ivy" to see a CTI.
        conjecture [eventually_at_least_one_candidate_value]
            intertwined(N) & voted_nominate(N, X)
                -> (confirmed_nominate(N, X) |
                    (exists N1, N2 . N1 ~= N2 &
                                     voted_nominate(N2, X) &
                                     ~received_vote_nominate(N1, N2, X)) |
                    (exists N1, N2 . N1 ~= N2 &
                                     accepted_nominate(N2, X) &
                                     ~received_accept_nominate(N1, N2, X)))
    } with actions, qi_intertwined
}
